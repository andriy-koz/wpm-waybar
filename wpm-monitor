#!/usr/bin/env python3
"""WPM typing speed monitor daemon for Waybar on Wayland.

Reads raw keyboard events via evdev, detects typing bursts,
and outputs JSON for the custom/wpm-live Waybar module.
Also writes state to /tmp/wpm-monitor.json for burst/avg modules.
"""

import asyncio
import json
import os
import signal
import sys
import tempfile
import time

try:
    import evdev
    from evdev import ecodes
except ImportError:
    # Output error state and exit
    err = {"text": "\U000f0324 ?", "tooltip": "python-evdev not installed\nsudo pacman -S python-evdev", "class": "error"}
    print(json.dumps(err), flush=True)
    sys.exit(1)

# Typeable key codes: letters, numbers, punctuation, space, enter, backspace, tab
TYPEABLE_KEYS = set()
# Letters A-Z
for i in range(ecodes.KEY_Q, ecodes.KEY_P + 1):
    TYPEABLE_KEYS.add(i)
for i in range(ecodes.KEY_A, ecodes.KEY_L + 1):
    TYPEABLE_KEYS.add(i)
for i in range(ecodes.KEY_Z, ecodes.KEY_M + 1):
    TYPEABLE_KEYS.add(i)
# Numbers 1-0
for i in range(ecodes.KEY_1, ecodes.KEY_0 + 1):
    TYPEABLE_KEYS.add(i)
# Punctuation and special typeable keys
TYPEABLE_KEYS.update([
    ecodes.KEY_MINUS, ecodes.KEY_EQUAL, ecodes.KEY_LEFTBRACE, ecodes.KEY_RIGHTBRACE,
    ecodes.KEY_SEMICOLON, ecodes.KEY_APOSTROPHE, ecodes.KEY_GRAVE, ecodes.KEY_BACKSLASH,
    ecodes.KEY_COMMA, ecodes.KEY_DOT, ecodes.KEY_SLASH,
    ecodes.KEY_SPACE, ecodes.KEY_ENTER, ecodes.KEY_BACKSPACE, ecodes.KEY_TAB,
    ecodes.KEY_102ND,
])

# Letter keys used to identify keyboards (vs mice/other devices)
LETTER_KEYS = set()
for i in range(ecodes.KEY_Q, ecodes.KEY_P + 1):
    LETTER_KEYS.add(i)
for i in range(ecodes.KEY_A, ecodes.KEY_L + 1):
    LETTER_KEYS.add(i)
for i in range(ecodes.KEY_Z, ecodes.KEY_M + 1):
    LETTER_KEYS.add(i)

BURST_TIMEOUT = 2.0  # seconds of inactivity to end a burst
STATE_FILE = "/tmp/wpm-monitor.json"
TICK_INTERVAL = 0.2  # 200ms output interval
SCAN_INTERVAL = 5.0  # 5s device scan interval

# Shared state
chars_in_burst = 0
burst_start_time = 0.0
last_key_time = 0.0
burst_active = False

last_burst_wpm = 0
burst_count = 0
total_chars = 0
session_burst_wpm_sum = 0.0

monitored_paths: set[str] = set()
permission_error = False


def reset_session(signum=None, frame=None):
    global last_burst_wpm, burst_count, total_chars, session_burst_wpm_sum
    global chars_in_burst, burst_start_time, last_key_time, burst_active
    last_burst_wpm = 0
    burst_count = 0
    total_chars = 0
    session_burst_wpm_sum = 0.0
    chars_in_burst = 0
    burst_start_time = 0.0
    last_key_time = 0.0
    burst_active = False


signal.signal(signal.SIGUSR1, reset_session)


def calc_wpm(chars: int, start: float, end: float) -> int:
    elapsed = end - start
    if elapsed < 0.5:
        return 0
    words = chars / 5.0
    minutes = elapsed / 60.0
    return max(0, round(words / minutes))


def is_keyboard(dev: evdev.InputDevice) -> bool:
    caps = dev.capabilities(verbose=False)
    ev_key_caps = caps.get(ecodes.EV_KEY, [])
    return any(k in ev_key_caps for k in LETTER_KEYS)


def finish_burst():
    global burst_active, chars_in_burst, last_burst_wpm, burst_count
    global total_chars, session_burst_wpm_sum, burst_start_time
    if chars_in_burst >= 5:  # minimum chars for a meaningful burst
        wpm = calc_wpm(chars_in_burst, burst_start_time, last_key_time)
        if wpm > 0:
            last_burst_wpm = wpm
            burst_count += 1
            session_burst_wpm_sum += wpm
    total_chars += chars_in_burst
    chars_in_burst = 0
    burst_active = False
    burst_start_time = 0.0


def on_key(code: int):
    global chars_in_burst, burst_start_time, last_key_time, burst_active
    if code not in TYPEABLE_KEYS:
        return
    now = time.monotonic()
    # Check if previous burst should end
    if burst_active and (now - last_key_time) > BURST_TIMEOUT:
        finish_burst()
    # Start new burst if needed
    if not burst_active:
        burst_active = True
        burst_start_time = now
        chars_in_burst = 0
    chars_in_burst += 1
    last_key_time = now


async def device_reader(dev: evdev.InputDevice):
    try:
        async for event in dev.async_read_loop():
            if event.type == ecodes.EV_KEY and event.value == 1:  # key down
                on_key(event.code)
    except (OSError, IOError):
        # Device disconnected
        monitored_paths.discard(dev.path)


async def scanner():
    global permission_error
    while True:
        try:
            devices = [evdev.InputDevice(path) for path in evdev.list_devices()]
            for dev in devices:
                if dev.path in monitored_paths:
                    dev.close()
                    continue
                if is_keyboard(dev):
                    monitored_paths.add(dev.path)
                    asyncio.create_task(device_reader(dev))
                else:
                    dev.close()
            if not permission_error and not monitored_paths and not devices:
                permission_error = True
        except PermissionError:
            permission_error = True
        except Exception:
            pass
        await asyncio.sleep(SCAN_INTERVAL)


def build_state() -> dict:
    now = time.monotonic()
    active = burst_active and (now - last_key_time) <= BURST_TIMEOUT

    # If burst timed out but wasn't finalized yet, finalize it
    if burst_active and not active:
        finish_burst()

    live_wpm = 0
    if active and chars_in_burst > 0:
        live_wpm = calc_wpm(chars_in_burst, burst_start_time, now)

    session_avg = 0
    if burst_count > 0:
        session_avg = round(session_burst_wpm_sum / burst_count)

    return {
        "live_wpm": live_wpm,
        "active": active,
        "last_burst_wpm": last_burst_wpm,
        "session_avg_wpm": session_avg,
        "burst_count": burst_count,
        "total_chars": total_chars + chars_in_burst,
        "error": permission_error,
    }


def write_state(state: dict):
    try:
        tmp = STATE_FILE + ".tmp"
        with open(tmp, "w") as f:
            json.dump(state, f)
        os.replace(tmp, STATE_FILE)
    except OSError:
        pass


def format_live_output(state: dict) -> str:
    if state["error"]:
        obj = {
            "text": "\U000f0324 ?",
            "tooltip": "Cannot read input devices\nsudo usermod -aG input $USER\nthen log out and back in",
            "class": "error",
        }
        return json.dumps(obj)

    if state["active"]:
        wpm = state["live_wpm"]
        text = f"\U000f0324 {wpm}" if wpm > 0 else "\U000f0324"
        total = state["total_chars"]
        tooltip = f"Live: {wpm} WPM\nBurst chars: {state['total_chars'] - (state['total_chars'] - total)}\nSession: {state['burst_count']} bursts, {state['total_chars']} chars"
        obj = {"text": text, "tooltip": tooltip, "class": "active"}
    else:
        tooltip = f"WPM monitor idle\nSession: {state['burst_count']} bursts, {state['total_chars']} chars"
        obj = {"text": "\U000f0324", "tooltip": tooltip, "class": "idle"}

    return json.dumps(obj)


async def output_ticker():
    while True:
        state = build_state()
        write_state(state)
        line = format_live_output(state)
        try:
            print(line, flush=True)
        except BrokenPipeError:
            sys.exit(0)
        await asyncio.sleep(TICK_INTERVAL)


async def main():
    # Clean up stale state file
    try:
        os.unlink(STATE_FILE)
    except FileNotFoundError:
        pass

    await asyncio.gather(
        scanner(),
        output_ticker(),
    )


if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        pass
    finally:
        try:
            os.unlink(STATE_FILE)
        except FileNotFoundError:
            pass
